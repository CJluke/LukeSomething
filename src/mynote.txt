spring AOP
面向切面是鬼话，人话就是：
本质上就是运行时重写类方法，实现上就是运行时生成代理类。简单的说就是代理模式。
代理模式还不简单啊，创建代理直接使用 JDKProxyFactory 啊，但是JDKProxyFactory只能生成接口的子类，生成抽象类的子类自行搜索啊。
像日志，权限，安全，事务等非核心业务的逻辑代码，重写类方法时加入这些业务逻辑生成代理类，这样就不用在每次需要使用这些功能的方法中加入这些代码，极大的减少了代码量，避免代码冗余


spring ioc

所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。

而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）

￼￼￼

jvm

程序计数器：相当于一个程序执行过程中的行号指示器，类似于操作系统中的ip，指向当前执行的虚拟机字节码地址。如果执行的是Java方法，计数器就记录者正在执行的虚拟机字节码指令的地址。如果是native 方法，计数器为空

虚拟机栈：虚拟机栈就是java方法的内存模型，每一个线程在执行时会有自己的一个虚拟机栈，在运行过程中把所调用方法封装为一个栈帧，然后将栈帧存放在栈里面。栈帧包含了一个方法执行时的相关信息，包括方法用到的局部变量，操作数，动态链接等。

本地方法栈：类似于虚拟机栈，只不过他存放的是Native方法。

堆：堆是相对来说占内存最大的一块，用来存放所有线程创建的类的对象实例。方法调用中如果创建了对象，会把这个对象实例存放在堆，然后将对于这个对象的引用存放在栈中，这样就可以方法对象了。对于内存的回收，也就是对堆内存的回收了。
方法区：存放虚拟机加载的类的信息和一些常量、静态变量等，这些内容一般是不可变的。

方法区：主要是存储类信息，常量池（static常量和static变量），编译后的代码（字节码）等数据


通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。

try-catch-finally
当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。


JVM 是如何处理异常的？
在一个方法中如果发生异常，这个方法会创建一个一场对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。
JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。

Maven是Java项目构建工具，可以用于管理Java依赖，还可以用于编译、打包以及发布Java项目，

注解
java中的注解是一种继承自接口`java.lang.annotation.Annotation`的特殊接口。
注解作用：每当你创建描述符性质的类或者接口时,一旦其中包含重复性的工作，就可以考虑使用注解来简化与自动化该过程。

首先,创建一个注解,用关键字@interface来声明,这是一个注解类.@Target来声明注解目标, @Retention用来说明该注解类的生命周期.


反射
反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是

Java 反射主要提供以下功能：
* 		在运行时判断任意一个对象所属的类；
* 		在运行时构造任意一个类的对象；
* 		在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
* 		在运行时调用任意一个对象的方法
重点：是运行时而不是编译时

为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。

从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：
* 获取类的 Class 对象实例
Class clz = Class.forName("com.zhenai.api.Apple");
* 根据 Class 对象实例获取 Constructor 对象
Constructor appleConstructor = clz.getConstructor();
* 使用 Constructor 对象的 newInstance 方法获取反射类对象
Object appleObj = appleConstructor.newInstance();
而如果要调用某一个方法，则需要经过下面的步骤：
* 获取方法的 Method 对象
Method setPriceMethod = clz.getMethod("setPrice", int.class);
* 利用 invoke 方法调用方法
setPriceMethod.invoke(appleObj, 14);


类加载机制

 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。


反向代理，负载均衡
反向代理服务器：nginx
正向代理：翻墙，服务器只知道代理服务器在发起请求，不知道到底是哪个客户端发起的请求（一对一或多队一）
反向代理：客户端只知道自己向代理服务器发起请求，并不知道到底是那个具体是那个服务器处理的请求，通常应用于服务器集群，配合负载均衡使用（一对多或多对多）